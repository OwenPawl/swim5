<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Lesson Manager</title>
  <link rel="apple-touch-icon" href="Swimming Person Icon.PNG">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <!-- Fonts and Icons -->
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Nunito:wght@600;700;800&display=swap");
    @import url("https://unpkg.com/@phosphor-icons/web@2.1.1/src/css/phosphor.css");

    :root {
      --blue: #007bb4;
      --blue-strong: #006694;
      --green: #00833d;
      --red: #850000;
      --surface: #f7fbff;
      --ink: #0b2a3c;
      --muted: #6b7a86;
      --card: #ffffff;
      --shadow: 0 10px 30px rgba(0, 59, 92, 0.12);
      --radius-lg: 18px;
      --nav-height: 74px;
      --content-bottom-pad: calc(var(--nav-height) + 104px);
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

    body {
      margin: 0;
      background: radial-gradient(circle at 10% 10%, rgba(0, 123, 180, 0.08), transparent 35%),
                  radial-gradient(circle at 90% 0%, rgba(0, 131, 61, 0.08), transparent 35%),
                  #e9f5ff;
      color: var(--ink);
      font-family: "Nunito", "Arial", "Helvetica", sans-serif;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      padding: 10px;
      padding-bottom: calc(var(--nav-height) + 14px);
      overscroll-behavior-y: contain;
    }

    /* Layout */
    .app-shell {
      width: min(960px, 100%);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* Top Bar & Date Controls */
    .top-bar { display: flex; justify-content: center; padding: 8px 10px; }
    
    .date-controls {
      display: inline-flex; align-items: center; gap: 8px;
      background: var(--card); box-shadow: var(--shadow);
      border-radius: 999px; padding: 10px 12px;
    }

    .date-input {
      border: none; font-size: 17px; font-weight: 700; color: var(--ink);
      padding: 8px 10px; border-radius: 12px; background: #f0f6fb; outline: none;
    }

    .icon-btn {
      width: 42px; height: 42px; border-radius: 50%; border: none;
      background: var(--blue); color: white; font-size: 18px; font-weight: 700;
      box-shadow: 0 6px 18px rgba(0, 123, 180, 0.25); cursor: pointer;
      transition: transform 0.1s ease; display: grid; place-items: center;
    }
    .icon-btn:active { transform: scale(0.95); }

    /* Main Content Card */
    .content-card {
      background: var(--card); box-shadow: var(--shadow);
      border-radius: var(--radius-lg); padding: 14px 12px var(--content-bottom-pad);
      min-height: 60vh; position: relative;
    }

    .screen-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
    .screen-title { font-size: 22px; font-weight: 800; margin: 0; color: var(--ink); }

    /* Tables */
    .table-wrapper {
      background: linear-gradient(180deg, #f5faff, #f0f6fb);
      border-radius: var(--radius-lg); padding: 6px;
      box-shadow: inset 0 0 0 1px rgba(0, 123, 180, 0.05);
      overflow-x: auto;
    }

    .data-table {
      width: 100%; border-collapse: collapse; background: #f9fcff;
      border-radius: 12px; overflow: hidden; table-layout: auto;
    }

    .data-table th, .data-table td {
      padding: 12px 10px; text-align: left; font-size: 15px;
      border-bottom: 1px solid rgba(0, 123, 180, 0.08); vertical-align: middle;
      line-height: 1.3;
    }
    .data-table th { font-weight: 800; color: var(--muted); font-size: 13px; text-transform: uppercase; letter-spacing: 0.5px; }
    .data-table tr:last-child td { border-bottom: none; }
    
    /* Column Sizing */
    .col-time { width: 1%; white-space: nowrap; }
    .col-dur { width: 1%; white-space: nowrap; text-align: center; color: var(--muted); font-weight: 700;}
    .col-main { max-width: 50vw; overflow: hidden; }
    .name-text { font-weight: 800; color: var(--blue); display: block; }
    .sub-text { font-size: 0.9em; color: var(--muted); display: block; margin-top: 2px; }
    
    /* Styling for internal slots (Note Time, Paid Break, Open) */
    .row-internal .name-text { color: var(--muted); font-style: italic; }

    /* Buttons & Inputs */
    .cta, .ghost {
      border: none; border-radius: 14px; padding: 14px 16px;
      font-size: 16px; font-weight: 800; cursor: pointer;
      transition: transform 0.1s ease;
    }
    .cta { background: linear-gradient(145deg, var(--blue), var(--blue-strong)); color: #fff; box-shadow: 0 6px 20px rgba(0,123,180,0.3); }
    .cta:active, .ghost:active { transform: scale(0.98); }
    
    .check-in-btn {
      width: 94px; height: 40px; border-radius: 10px; border: none;
      font-weight: 800; font-size: 14px; color: white; cursor: pointer;
      transition: all 0.2s; margin: 2px 0;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .status-registered { background-color: var(--green); }
    .status-completed { background-color: var(--green); opacity: 0.8; }
    .status-noshow { background-color: var(--red); }
    .note-btn { background-color: var(--blue); width: auto; padding: 0 16px; }

    /* Navigation */
    .bottom-nav {
      position: fixed; bottom: 0; left: 50%; transform: translateX(-50%);
      width: min(960px, 100%); height: var(--nav-height);
      background: var(--card); border-radius: 18px 18px 0 0;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.05);
      display: grid; grid-template-columns: 1fr 1fr; padding: 0 12px; z-index: 100;
    }
    .nav-btn {
      background: none; border: none; color: var(--muted);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      gap: 4px; font-weight: 700; font-size: 12px; cursor: pointer;
    }
    .nav-btn i { font-size: 24px; margin-bottom: 2px; }
    .nav-btn.active { color: var(--blue); }

    /* Floating Action Bar (Attendance) */
    .floating-actions {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: calc(var(--nav-height) + 12px);
      width: min(940px, calc(100% - 20px));
      display: flex; gap: 10px; z-index: 90;
      transition: transform 0.3s ease;
    }
    .floating-actions.hidden { transform: translate(-50%, 150%); }
    .floating-actions input { flex: 1; height: 50px; }
    .btn-submit { background: var(--green); color: white; }
    .btn-reset { background: white; color: var(--blue-strong); border: 1px solid rgba(0,123,180,0.2); }

    /* Utilities */
    .badge-new {
      display: inline-block; padding: 2px 6px; font-size: 10px; font-weight: 800;
      color: var(--green); background: rgba(0, 131, 61, 0.1); border-radius: 4px;
      margin-left: 6px; vertical-align: middle; border: 1px solid rgba(0,131,61,0.2);
    }
    .hidden { display: none !important; }
    .pull-indicator {
      position: fixed; top: 10px; left: 50%; transform: translate(-50%, -150%);
      background: var(--blue); color: white; padding: 8px 16px; border-radius: 20px;
      font-weight: 700; font-size: 14px; z-index: 200; transition: transform 0.2s;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .pull-visible { transform: translate(-50%, 20px); }

    /* Mobile Optimization */
    @media (max-width: 520px) {
      .app-shell { gap: 8px; }
      .content-card { padding: 12px 8px 120px; }
      .data-table th, .data-table td { padding: 10px 6px; font-size: 14px; }
      .check-in-btn { width: 80px; font-size: 13px; }
    }
  </style>
</head>
<body>

  <div class="pull-indicator" id="pullIndicator">Release to refresh</div>

  <div class="app-shell">
    <!-- Header -->
    <header class="top-bar">
      <div class="date-controls">
        <button class="icon-btn" id="prevDate"><i class="ph-bold ph-arrow-left"></i></button>
        <input class="date-input" id="dateInput" type="date">
        <button class="icon-btn" id="nextDate"><i class="ph-bold ph-arrow-right"></i></button>
      </div>
    </header>

    <!-- Main Content -->
    <main class="content-card">
      <div class="screen-header">
        <h2 class="screen-title" id="pageTitle">Schedule</h2>
        <div id="loadingSpinner" class="hidden"><i class="ph-duotone ph-spinner ph-spin"></i></div>
      </div>

      <div class="table-wrapper">
        <table class="data-table" id="mainTable">
          <!-- Content injected by JS -->
        </table>
      </div>
    </main>
  </div>

  <!-- Attendance Actions (Floating) -->
  <div class="floating-actions hidden" id="attendanceActions">
    <input class="cta btn-submit" type="button" value="Submit Attendance" id="btnSubmit">
    <input class="ghost btn-reset" type="button" value="Reset View" id="btnReset">
  </div>

  <!-- Bottom Navigation -->
  <nav class="bottom-nav">
    <button class="nav-btn active" data-view="schedule">
      <i class="ph-fill ph-calendar-check"></i>
      <span>Schedule</span>
    </button>
    <button class="nav-btn" data-view="attendance">
      <i class="ph-fill ph-clipboard-check"></i>
      <span>Attendance</span>
    </button>
  </nav>

  <!-- Application Logic -->
  <script>
    // --- Configuration & Constants ---
    const CONFIG = {
      clientId: "ixG6UsN5JaLPYFgwjhTAtmdg8UNU7IZYK2lOxTo3",
      // These client IDs are used for internal events like Note Time or Paid Breaks.
      // 11485475: Note Time, 11559838: Paid Break (Examples)
      ignoredClientIds: [11485475, 11559838, 13602611, 13167161],
      apiBase: "https://mcdonaldswimschool.pike13.com/api/v2/desk",
      reportApi: "https://mcdonaldswimschool.pike13.com/desk/api/v3/reports/clients/queries"
    };

    // --- State Management ---
    const Store = {
      currentDate: new Date().toLocaleDateString('en-CA'),
      currentView: 'schedule', // 'schedule' or 'attendance'
      staffId: localStorage.getItem("staff_id"),
      accessToken: localStorage.getItem("access_token"),
      scheduleData: [], // Central data store
      isLoading: false
    };

    // --- Auth & Initialization Module ---
    const Auth = {
      init() {
        if (window.location.hash.includes("access_token")) {
          const token = window.location.hash.substring(14, 54);
          localStorage.setItem("access_token", token);
          window.history.replaceState(null, null, window.location.pathname);
          Store.accessToken = token;
        }
        if (!Store.accessToken) {
          window.location.href = `https://pike13.com/oauth/authorize?client_id=${CONFIG.clientId}&response_type=token&redirect_uri=${window.location.href}`;
          return;
        }
        if (!Store.staffId) {
          API.fetchStaffId().then(id => {
            Store.staffId = id;
            localStorage.setItem("staff_id", id);
            App.loadData();
          });
        } else {
          App.loadData();
        }
      }
    };

    // --- API Module ---
    const API = {
      getHeaders() {
        return {
          "Authorization": `Bearer ${Store.accessToken}`,
          "Content-Type": "application/json"
        };
      },

      async fetchStaffId() {
        const res = await fetch(`${CONFIG.apiBase}/staff_members/me`, { headers: this.getHeaders() });
        const json = await res.json();
        return json.staff_members?.[0]?.id;
      },

      // STAGE 1: Fetch the basic structure (Events, Times, Notes, Breaks)
      async getBasicEvents(date) {
        if (!Store.staffId) return [];
        
        // Format date to Pike13's required ISO midnight format (T00:00:00Z)
        const [y, m, d] = date.split('-').map(Number);
        const localMidnight = new Date(y, m - 1, d); 
        const queryDate = localMidnight.toISOString();

        try {
          const [eventsRes, opensRes] = await Promise.all([
            fetch(`${CONFIG.apiBase}/event_occurrences.json?from=${queryDate}&staff_member_ids=${Store.staffId}`, { headers: this.getHeaders() }),
            fetch(`${CONFIG.apiBase}/available_times.json?from=${queryDate}`, { headers: this.getHeaders() })
          ]);

          const eventsData = await eventsRes.json();
          const opensData = await opensRes.json();

          let rawList = [];

          // Process Events (Client Lessons + Notes + Breaks)
          (eventsData.event_occurrences || []).forEach(evt => {
             if (evt.people && evt.people.length > 0) {
                 evt.people.forEach(p => {
                    const clientId = Number(p.id);
                    const isInternal = CONFIG.ignoredClientIds.includes(clientId);

                    // Use event name as a placeholder before report enrichment
                    rawList.push({
                        id: p.id,
                        visitId: p.visit_id,
                        state: p.visit_state,
                        start: evt.start_at,
                        end: evt.end_at,
                        name: isInternal ? (evt.name || "Internal Slot") : p.name, 
                        type: isInternal ? "internal_client" : "lesson", 
                        level: "", 
                        isNew: false,
                        age: ""
                    });
                 });
             }
          });

          // Process Opens (Available Times)
          (opensData.available_times || []).filter(open => open.staff_member_id == Store.staffId).forEach(open => {
            rawList.push({
              id: "open-" + open.id,
              locationId: open.location_id,
              state: "available",
              start: open.start_at,
              end: open.end_at,
              name: "Open",
              type: "open",
              level: "",
              isNew: false,
              age: ""
            });
          });

          // Sort by time
          return rawList.sort((a, b) => new Date(a.start) - new Date(b.start));

        } catch (err) {
          console.error("Fetch error:", err);
          return [];
        }
      },

      // STAGE 2: Fetch details for Clients and apply name fix
      async enrichWithReports(currentList) {
         // Get unique client IDs (numeric and not already marked as internal/open)
         const clientIds = currentList
            .filter(x => x.id && !isNaN(x.id))
            .map(x => x.id);

         if (clientIds.length === 0) return currentList;

         const uniqueIds = [...new Set(clientIds)];

         try {
            // Report Query payload
            const queryBody = {
                data: {
                    type: "queries",
                    attributes: {
                        // Fields: [0: person_id, 1: person_name, 2: first_visit_date, 3: birthdate, 4: custom_field_180098(Level)]
                        fields: ["person_id", "person_name", "first_visit_date", "birthdate", "custom_field_180098"],
                        filter: ["or", uniqueIds.map(id => ["eq", "person_id", String(id)])]
                    }
                }
            };
            
            // NOTE: Using desk/api/v3 requires the specific authentication method, using the provided example key
            const reportRes = await fetch(CONFIG.reportApi, {
                method: "POST",
                headers: { ...this.getHeaders(), "Authorization": "Bearer kZEbOpElCispz8mFkeoTsVGVCvSP23mZG82G7eeN" },
                body: JSON.stringify(queryBody)
            });

            if (!reportRes.ok) {
                 console.error("Report fetch failed with status:", reportRes.status);
                 return currentList; // Return unenriched data on error
            }

            const reportJson = await reportRes.json();
            const rows = reportJson.data?.attributes?.rows || [];
            
            // Map details back to list
            return currentList.map(item => {
                if (item.type === 'open') return item;
                
                const details = rows.find(r => Number(r[0]) === Number(item.id));
                if (details) {
                    const clientId = Number(item.id);
                    const isInternal = CONFIG.ignoredClientIds.includes(clientId);
                    
                    // The client's actual name is at index 1 in the new report structure
                    const realName = details[1]; 

                    // 1. ALWAYS use the real name
                    item.name = realName || item.name;
                    item.type = isInternal ? "internal_client" : "lesson";
                    
                    if (isInternal) {
                        // 2. For internal clients, suppress level/age/new status
                        item.level = "";
                        item.isNew = false;
                        item.age = "";
                    } else {
                        // 3. For regular lessons, calculate and store details
                        const levelStr = details[4] || ""; // custom_field_180098
                        const firstVisit = details[2];
                        const birthdate = details[3];

                        item.level = /\d/.test(levelStr[6]) ? levelStr[6] : (levelStr.split(" ")[0]?.[0] || "?");
                        item.isNew = !firstVisit; 
                        
                        if (birthdate) {
                            const diff = Date.now() - new Date(birthdate);
                            // Age in years, rounded to 1 decimal place
                            item.age = (Math.floor(diff / (31557600000) * 10) / 10).toFixed(1); 
                        }
                    }
                }
                return item;
            });

         } catch (e) {
             console.error("Report fetch failed:", e);
             return currentList;
         }
      },

      async updateAttendance(updates) {
        const headers = this.getHeaders();
        // Use a Promise.allSettled to handle all updates concurrently and robustly
        const results = await Promise.allSettled(updates.flatMap(u => {
            const reset = fetch(`${CONFIG.apiBase}/visits/${u.visitId}`, {
                method: "PUT", headers, body: JSON.stringify({ visit: { state_event: "reset" } })
            });
            const targetState = u.type === "Check In" ? "complete" : "noshow";
            const updateState = fetch(`${CONFIG.apiBase}/visits/${u.visitId}`, {
                method: "PUT", headers, body: JSON.stringify({ visit: { state_event: targetState } })
            });
            let punch = Promise.resolve();
            if (targetState === "noshow") {
                // Pike13 expects a punch for No Show status
                punch = fetch(`${CONFIG.apiBase}/punches`, {
                    method: "POST", headers, body: JSON.stringify({ punch: { visit_visit_id: u.visitId } }) 
                });
            }
            return [reset, updateState, punch];
        }));

        const failed = results.filter(r => r.status === 'rejected');
        if (failed.length > 0) {
            console.error("Some attendance submissions failed:", failed);
        }
      }
    };

    // --- Logic / Data Processor ---
    const Processor = {
        formatTime(isoString) {
            // Formats to PST/PDT time (e.g., 9:00 AM)
            return new Date(isoString).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', timeZone: 'America/Los_Angeles' });
        },
        
        // Merges consecutive slots for the same client (or internal event)
        mergeBlocks(data) {
            if (!data || !data.length) return [];
            
            const merged = [];
            for (let i = 0; i < data.length; ) {
                let current = { ...data[i] };
                // Initialize visitors array for this block
                current.visitors = [{ 
                    id: current.id, 
                    visitId: current.visitId, 
                    state: current.state, 
                    name: current.name,
                    type: current.type 
                }];
                
                let j = i + 1;
                // Merge if same ID AND consecutive times
                while (j < data.length && 
                       data[j].id === current.id && 
                       new Date(data[j].start).getTime() === new Date(current.end).getTime()) {
                    
                    current.end = data[j].end;
                    current.visitors.push({ 
                        id: data[j].id, 
                        visitId: data[j].visitId, 
                        state: data[j].state, 
                        name: data[j].name,
                        type: data[j].type
                    });
                    j++;
                }
                
                // Formatting Name for Display
                if (current.type === 'internal_client' || current.type === 'open') {
                    // Use full name/title for internal slots
                    current.displayName = current.name;
                    current.displayLevel = "";
                } else if (current.state === 'late_canceled' || current.state === 'canceled') {
                    current.displayName = `CANCELED: ${current.name}`;
                    current.displayLevel = "â€”";
                } else {
                    // Shorten client name (First Initial of Last Name)
                    const parts = current.name.trim().split(/\s+/);
                    const shortName = parts.length > 1 
                        ? `${parts[0]} ${parts[parts.length-1][0]}.` 
                        : parts[0];
                    // Title-case the name
                    current.displayName = shortName.toLowerCase().replace(/\b\w/g, c => c.toUpperCase());
                    current.displayLevel = current.level;
                }
                
                const duration = (new Date(current.end) - new Date(current.start)) / 60000;
                current.duration = duration;
                current.formattedStart = this.formatTime(current.start);

                merged.push(current);
                i = j;
            }
            return merged;
        },

        groupByTime(mergedList) {
            const groups = {};
            mergedList.forEach(item => {
                if (!groups[item.start]) groups[item.start] = [];
                groups[item.start].push(item);
            });
            return Object.entries(groups).sort((a, b) => new Date(a[0]) - new Date(b[0]));
        }
    };

    // --- UI Module ---
    const UI = {
        els: {
            table: document.getElementById('mainTable'),
            dateInput: document.getElementById('dateInput'),
            pageTitle: document.getElementById('pageTitle'),
            attendanceActions: document.getElementById('attendanceActions'),
            spinner: document.getElementById('loadingSpinner'),
            navBtns: document.querySelectorAll('.nav-btn')
        },

        render() {
            this.updateNav();
            this.els.attendanceActions.classList.toggle('hidden', Store.currentView !== 'attendance');
            
            // Show spinner only if we have NO data yet
            if (Store.isLoading && Store.scheduleData.length === 0) {
                this.els.table.innerHTML = '<tr><td colspan="5" style="text-align:center; padding: 30px;">Loading...</td></tr>';
                this.els.spinner.classList.remove('hidden');
                return;
            }
            this.els.spinner.classList.add('hidden');

            let dataToRender = Store.scheduleData;

            // FILTER: Filter logic based on view
            if (Store.currentView === 'attendance') {
                // Attendance view: Remove Opens and internal_client slots
                dataToRender = dataToRender.filter(item => item.type === 'lesson');
            } else {
                // Schedule view: Remove canceled/late-canceled lessons
                dataToRender = dataToRender.filter(item => 
                   !(item.type === 'lesson' && (item.state === 'canceled' || item.state === 'late_canceled'))
                );
            }
            
            const processed = Processor.mergeBlocks(dataToRender);
            
            if (processed.length === 0) {
                this.els.table.innerHTML = '<tr><td colspan="5" style="text-align:center; padding: 30px; color: var(--muted);">No scheduled items found.</td></tr>';
                return;
            }

            if (Store.currentView === 'schedule') {
                this.renderSchedule(processed);
            } else {
                this.renderAttendance(processed); 
            }
        },

        renderSchedule(items) {
            this.els.pageTitle.textContent = "Schedule";
            const groups = Processor.groupByTime(items);
            let html = `<thead><tr><th class="col-time">Start</th><th class="col-dur">Min</th><th class="col-main">Student</th><th>Lvl</th><th>Age</th></tr></thead><tbody>`;

            groups.forEach(([startIso, items]) => {
                const timeStr = Processor.formatTime(startIso).replace(/ AM| PM/,''); 
                const duration = items[0].duration; 
                
                let nameHtml = items.map(i => {
                    let badge = i.isNew ? '<span class="badge-new">NEW</span>' : '';
                    return `<span class="name-text">${i.displayName} ${badge}</span>`;
                }).join('<div style="height:8px"></div>'); 

                let lvlHtml = items.map(i => i.displayLevel || '').join('<br>');
                let ageHtml = items.map(i => i.age || '').join('<br>');
                
                // Special styling for internal rows (Note Time, Paid Break, Open)
                let rowClass = items.some(i => i.type === 'internal_client' || i.type === 'open') ? 'row-internal' : '';

                html += `
                    <tr class="${rowClass}">
                        <td class="col-time"><b>${timeStr}</b></td>
                        <td class="col-dur">${duration}</td>
                        <td class="col-main">${nameHtml}</td>
                        <td>${lvlHtml}</td>
                        <td>${ageHtml}</td>
                    </tr>
                `;
            });
            html += "</tbody>";
            this.els.table.innerHTML = html;
        },

        renderAttendance(items) {
            this.els.pageTitle.textContent = "Attendance";
            let html = `<thead><tr><th class="col-main">Student</th><th>Check In / Status</th><th>Notes</th></tr></thead><tbody>`;

            items.forEach(item => {
                const firstState = item.visitors[0].state;
                const color = firstState === 'noshowed' ? 'var(--red)' : (firstState === 'completed' ? 'var(--green)' : 'var(--blue)');

                // Each visitor (if merged) gets their own button to submit attendance
                let checkinButtons = item.visitors.map(v => {
                    const isNoShow = v.state === 'noshowed';
                    const isComplete = v.state === 'completed';
                    const btnClass = isNoShow ? 'status-noshow' : (isComplete ? 'status-completed' : 'status-registered');
                    const btnText = isNoShow || isComplete ? (isNoShow ? 'No Show' : 'Check In') : 'Check In'; // Initial state is 'Check In' for registered/unmarked
                    const currentState = v.state; // registered, completed, noshowed

                    return `<button class="check-in-btn ${btnClass}" 
                            data-visit-id="${v.visitId}" 
                            data-current-state="${currentState}"
                            data-original-state="${currentState}"
                            onclick="App.toggleCheckIn(this)">${btnText}</button>`;
                }).join('<br>');

                html += `
                    <tr>
                        <td class="col-main">
                            <span class="name-text" style="color:${color}">${item.displayName}</span>
                            <span class="sub-text">${item.formattedStart} (${item.duration}m)</span>
                        </td>
                        <td>${checkinButtons}</td>
                        <td>
                            <button class="check-in-btn note-btn" onclick="window.open('https://mcdonaldswimschool.pike13.com/people/${item.id}/notes', '_blank')">Notes</button>
                        </td>
                    </tr>
                `;
            });
            html += "</tbody>";
            this.els.table.innerHTML = html;
        },

        updateNav() {
            this.els.navBtns.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === Store.currentView);
            });
        }
    };

    // --- Main Controller ---
    const App = {
        init() {
            UI.els.dateInput.value = Store.currentDate;
            UI.els.dateInput.addEventListener('change', (e) => this.handleDateChange(e.target.value));
            document.getElementById('prevDate').addEventListener('click', () => this.offsetDate(-1));
            document.getElementById('nextDate').addEventListener('click', () => this.offsetDate(1));
            UI.els.navBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    Store.currentView = btn.dataset.view;
                    UI.render();
                });
            });
            document.getElementById('btnSubmit').addEventListener('click', this.submitAttendance);
            document.getElementById('btnReset').addEventListener('click', this.resetView);
            Auth.init();
            this.setupPullRefresh();
        },

        async loadData() {
            Store.isLoading = true;
            UI.render(); // Show loading UI immediately

            // Phase 1: Get Basic Schedule (Events, Notes, Opens)
            let basicData = await API.getBasicEvents(Store.currentDate);
            
            // Phase 2: Fetch Report Data (Client details and correct names)
            Store.scheduleData = await API.enrichWithReports(basicData);

            Store.isLoading = false;
            UI.render();
        },

        handleDateChange(newDate) {
            Store.currentDate = newDate;
            this.loadData();
        },

        offsetDate(days) {
            const d = new Date(Store.currentDate + "T00:00:00");
            d.setDate(d.getDate() + days);
            const newDate = d.toISOString().split('T')[0];
            UI.els.dateInput.value = newDate;
            this.handleDateChange(newDate);
        },

        toggleCheckIn(btn) {
            // Only allow toggling if current state is registered, noshowed, or the button has been marked for submission
            const isRegistered = btn.dataset.currentState === 'registered';
            const isNoShowed = btn.dataset.currentState === 'noshowed';
            const isMarkedNoShow = btn.dataset.type === "No Show";
            const isMarkedCheckIn = btn.dataset.type === "Check In";

            if (isRegistered || isMarkedNoShow) {
                // If registered or currently marked No Show, switch to Check In
                btn.innerText = "Check In";
                btn.classList.remove('status-noshow');
                btn.classList.add('status-registered');
                btn.dataset.type = "Check In";
            } else if (isNoShowed || isMarkedCheckIn) {
                 // If noshowed or currently marked Check In, switch to No Show
                btn.innerText = "No Show";
                btn.classList.remove('status-registered');
                btn.classList.add('status-noshow');
                btn.dataset.type = "No Show";
            }
            // For 'completed', we don't allow toggling, as it's a final state.
        },

        async submitAttendance() {
            const btns = [...document.querySelectorAll('.check-in-btn[data-visit-id]')];
            
            // Filter only buttons that have been interacted with (data-type set)
            const updates = btns.filter(b => b.dataset.type).map(b => ({
                visitId: b.dataset.visitId,
                type: b.dataset.type, // "Check In" or "No Show"
                currentState: b.dataset.currentState
            }));

            if (updates.length === 0) return;
            
            // Check for future date submission guard
            const selectedDate = new Date(Store.currentDate + "T23:59:59");
            if (new Date() < selectedDate) {
                // Cannot use alert(), so log error and reset UI
                console.error("Attendance cannot be submitted for future dates.");
                UI.els.table.innerHTML = '<tr><td colspan="3" style="text-align:center; color: var(--red);">Error: Events must be in the past to submit attendance.</td></tr>';
                setTimeout(() => App.loadData(), 3000);
                return;
            }

            UI.els.table.innerHTML = '<tr><td colspan="3" style="text-align:center; padding: 20px;">Submitting... Please wait.</td></tr>';
            
            // Only update if the action is changing the state (e.g., registered -> complete, registered -> noshow, noshowed -> complete)
            const changesToSubmit = updates.filter(u => {
                 const newStatus = u.type === "Check In" ? "completed" : "noshowed";
                 return u.currentState !== newStatus;
            });
            
            if (changesToSubmit.length > 0) {
                 await API.updateAttendance(changesToSubmit);
            }

            // Reload data after submission
            setTimeout(() => App.loadData(), 1000);
        },
        
        // Resets the temporary interaction state by reloading data
        resetView() { App.loadData(); },

        setupPullRefresh() {
            let startY = 0;
            let armed = false;
            const indicator = document.getElementById('pullIndicator');
            window.addEventListener('touchstart', e => {
                if (window.scrollY === 0) {
                    startY = e.touches[0].clientY;
                    armed = true;
                }
            }, {passive: true});
            window.addEventListener('touchmove', e => {
                if (!armed) return;
                const delta = e.touches[0].clientY - startY;
                if (delta > 80) {
                    indicator.classList.add('pull-visible');
                } else {
                    indicator.classList.remove('pull-visible');
                }
            }, {passive: true});
            window.addEventListener('touchend', () => {
                if (indicator.classList.contains('pull-visible')) {
                    location.reload();
                }
                armed = false;
                indicator.classList.remove('pull-visible');
            });
        }
    };

    document.addEventListener('DOMContentLoaded', () => App.init());
  </script>
</body>
</html>
